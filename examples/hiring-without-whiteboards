#!/usr/bin/env perl

# Copyright (c) 2019-2020 Christian Jaeger, copying@christianjaeger.ch
# This is free software. See the file COPYING.md that came bundled
# with this file.

use strict; use warnings; use warnings FATAL => 'uninitialized';
use Function::Parameters qw(:strict);
#use Sub::Call::Tail;

# find modules from functional-perl working directory (not installed)
use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../lib";

my $mainfile= "README.md";

sub usage {
    print "usage: $myname path/to/hiring-without-whiteboards/

  Parse the $mainfile file of a check-out of
  https://github.com/poteto/hiring-without-whiteboards, present it in
  a repl as an FP::Stream of Company objects via the `cs` function. Now
  you can do things like:

     cs->filter(fun(\$r) { \$r->locations->any(fun(\$l) { \$l=~ /\\bUK\\b/ }) })->show_items

  Use tab completion to learn about the available methods, and read
  the (probably not-so-fine) docs on functional-perl.org .

  See https://news.ycombinator.com/item?id=19290044 for a
  discussion.

";
    exit 1;
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
           "help"=> sub{usage},
           ) or exit 1;
usage unless @ARGV==1;

my ($basedir)= @ARGV;


use Chj::ruse;
use FP::Repl::Trap;
use FP::Repl;

use FP::List ":all";
use FP::Stream ":all";
use FP::IOStream ":all";
use FP::Path;
use FP::Array ":all";
use FP::Array_sort ":all";
use FP::Predicates ":all";
use FP::Ops ":all";
use FP::Combinators ":all";
use FP::Show;
use Chj::xperlfunc ":all";
use FP::PureArray;

use Chj::TEST;


package CountryOrRemote {
    use FP::Struct [],
        'FP::Struct::Show';
    use overload '""'=> sub {shift->string};
    _END_
}

package Remote {
    use FP::Struct [],
        'CountryOrRemote';
    method is_USA() { undef }
    method is_remote() { 1 }
    method string() { "Remote" }
    _END_
}
import Remote::constructors;
my $Remote = Remote();

package Country {
    use FP::Struct [],
        'CountryOrRemote';
    method is_remote() { 0 }
    _END_
}

# https://en.wikipedia.org/wiki/List_of_U.S._state_abbreviations
# Name => USPS

my $states= "
 Alabama        AL
 Alaska         AK
 Arizona        AZ
 Arkansas       AR
 California     CA
 Colorado       CO
 Connecticut    CT
 Delaware       DE
 Florida        FL
 Georgia        GA
 Hawaii         HI
 Idaho          ID
 Illinois       IL
 Indiana        IN
 Iowa           IA
 Kansas         KS
 Kentucky       KY
 Louisiana      LA
 Maine          ME
 Maryland       MD
 Massachusetts  MA
 Michigan       MI
 Minnesota      MN
 Mississippi    MS
 Missouri       MO
 Montana        MT
 Nebraska       NE
 Nevada         NV
 New Hampshire  NH
 New Jersey     NJ
 New Mexico     NM
 New York       NY
 North Carolina NC
 North Dakota   ND
 Ohio           OH
 Oklahoma       OK
 Oregon         OR
 Pennsylvania   PA
 Rhode Island   RI
 South Carolina SC
 South Dakota   SD
 Tennessee      TN
 Texas          TX
 Utah           UT
 Vermont        VT
 Virginia       VA
 Washington     WA
 West Virginia  WV
 Wisconsin      WI
 Wyoming        WY ";

my $nonstates= "
 American Samoa                 AS
 Guam                           GU
 Northern Mariana Islands       MP
 Puerto Rico                    PR
 U.S. Virgin Islands            VI
 Micronesia                     FM
 Marshall Islands               MH
 Palau                          PW
 U.S. Armed Forces – Americas   AA
 U.S. Armed Forces – Europe     AE
 U.S. Armed Forces – Pacific    AP";

package USPSCode {
    use FP::Struct ["name", "code", "is_state"],
        'Country';
    method is_USA() { 1 }
    method country_name() { "USA" }
    method string() { "$$self{code} (USA)" }
    _END_
}
import USPSCode::constructors;

fun parse_USPS_segment($str, $is_state) {
    $str=~ s/^\s+//;
    purearray(split /\n/, $str)->map(fun($line) {
        $line=~ s/^\s*(.*?)\s*\z/$1/s;
        my ($name,$code)= $line=~ /^(\S.*?\S)\s+(\w{2})\z/
            or die "no parse: '$line'";
        USPSCode($name, $code, $is_state)
    })
}

my $USPSCodes= parse_USPS_segment($states, 1)
    ->append(parse_USPS_segment($nonstates, 0));
my %USfromCode=
    map { $_->code => $_ } $USPSCodes->values;

package NonUSCountry {
    use FP::Struct ["country_name"],
        'Country';
    method is_USA() { 0 }
    method string() { $$self{country_name} }
    _END_
}
import NonUSCountry::constructors;

package City {
    use FP::Struct ["city", "country"],
        'FP::Struct::Show';
    use overload '""'=> sub {shift->string};

    method string() {
        $self->city.", ".$self->country
    }

    _END_
}
import City::constructors;

package Company {
    use FP::Struct ["name",
                    "URL",
                    "locations",
                    "maybe_process"],
      'FP::Struct::Show';

    method remote () {
        # not calling it is_remote since has_remote might be more
        # appropriate, and then just keep it short.
        $self->locations->any (the_method("is_remote"))
    }

    _END_
}
import Company::constructors;


# markdown line parsing

fun is_item ($s) {
    $s=~ /^-\s+/
}

fun is_heading_of ($pred) {
    fun ($s) {
        if (my ($txt)= $s=~ /^\s*#+\s*(.*)/) {
            &$pred ($txt)
        } else {
            0
        }
    }
}

*is_heading= is_heading_of (fun ($s) { 1 });
*is_AlsoSee= is_heading_of (fun ($s) { $s=~ /also *see/i });

fun is_hr ($s) {
    $s=~ /^---\s*$/
}

fun is_empty ($s) {
    $s=~ /^\s*$/
}

fun parse_country ($str) {
    $USfromCode{$str} // NonUSCountry($str)
}

fun parse_location($str) {
    if ($str=~ /^remote$/i) {
        $Remote
    } else {
        my @s= split /\s*,\s*/, $str;
        if (@s > 2) {
            die "more than one comma in: '$str'"
        } elsif (@s == 2) {
            my ($city, $country)= @s;
            City($city, parse_country($country))
        } else {
            parse_country($s[0])
        }
    }
}

fun parse_line ($line) {
    my $s=$line;
    $s=~ s/^-\s*//
      or die "line is not an item";
    my ($name, $url, $rest) = $s=~ /^\[(.*?)\] *\((.*?)\)\s*(.*)$/
      or die "missing link formatting in: '$s'";

    my @p= split /\s*\|\s*/, $rest;
    @p == 2 or @p == 3
      or die "rest does not contain 2 or 3 parts: '$rest'";
    my (undef, $locations, $process)= @p;
    Company ($name,
             $url,
             # / and ; used inconsistently:
             list(map { parse_location $_ } split m%\s*[/;]\s*%, $locations),
             $process)
}


TEST {
    parse_line "- [Accredible](https://www.accredible.com/careers) | Cambridge, UK / San Francisco, CA / Remote | Take home project, then a pair-programming and discussion onsite / Skype round."
}
  Company ("Accredible", "https://www.accredible.com/careers",
           list ("Cambridge, UK", "San Francisco, CA", "Remote"),
           "Take home project, then a pair-programming and discussion onsite / Skype round.");


# XX move?; name?
fun FP::Abstract::Sequence::drop_over ($l, $pred) {
    $l->drop_while (complement $pred)->drop_while ($pred)
}

fun companies () {
    xfile_lines_chomp ("$basedir/$mainfile")
      ->drop_over (*is_hr)
      ->take_while (complement *is_AlsoSee)
      ->filter (complement either (*is_heading, *is_empty))
      ->map (*parse_line)
}


# HACK: should really just use the repl printer (show) directly to
# show the whole results list, but show currently doesn't do
# multi-line pretty-printing; so:
fun print_showln ($v) {
    xprintln show $v
}
# XX see above, and move?
fun FP::Abstract::Sequence::show_items ($l) {
    $l->for_each (*print_showln)
}

fun cs() { companies() }

# let the user play with the data
repl;
