#!/usr/bin/env perl

my $copyright = <<'COPYRIGHT';
# Copyright 2021 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use warnings;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

my ($email_full) = $copyright =~ / by ([^\n]*)/s;

my ($mydir, $myname);

BEGIN {
    $0 =~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname) = ($1, $2);
}

sub usage {
    print STDERR map {"$_\n"} @_ if @_;
    print "$myname

  Read copy-paste from repl ('fperl' script or other FP::Repl
  invocation) and print as a series of Chj::TEST 'TEST' statements.

  ($email_full)
";
    exit(@_ ? 1 : 0);
}

use lib "$mydir/../lib/";

use FP::autobox;
use FP::Ops qw(the_method);
use Chj::xperlfunc qw(xprint);
use FP::Show;
use Chj::TEST;

# XX move

# up to 9 captures in $re, bundled in arrays
sub all_matches ($str, $re) {
    my @res;
    while ($str =~ m{$re}gc) {
        my @c;
        push @c, $1 if defined $1;
        push @c, $2 if defined $2;
        push @c, $3 if defined $3;
        push @c, $4 if defined $4;
        push @c, $5 if defined $5;
        push @c, $6 if defined $6;
        push @c, $7 if defined $7;
        push @c, $8 if defined $8;
        push @c, $9 if defined $9;
        die "can't handle more than 9 captures" if defined $10;
        push @res, \@c;
    }
    \@res
}

# only 1 capture in $re
sub all_matches1 ($str, $re) {
    my @res;
    while ($str =~ m{$re}gc) {
        die "no capture" unless defined $1;
        push @res, $1;
        die "got more than 1 capture" if defined $2;
    }
    \@res
}

# captures the whole string of all matches of $re
sub all_matches_whole ($str, $re) {
    my @res;
    while ($str =~ m{($re)}gc) {
        push @res, $1;
    }
    \@res
}

# The list of (the single capture all matches of $re), requiring them
# to follow each other continuously from the current pos. Returns the
# pos of the remainder after.
sub all_continuous_matches1 ($str, $re) {
    my @res;
    my $pos = pos($str) // 0;    # is it correct that undef pos means 0 ?
    while ($str =~ m{\G$re}gc) {
        $pos = pos($str);
        die "no capture" unless defined $1;
        push @res, $1;
        die "got more than 1 capture" if defined $2;
    }
    wantarray ? (\@res, $pos) : \@res
}

# captures the whole string of all matches of $re, requiring them to
# follow each other continuously from the current pos. Returns the pos
# of the remainder after.
sub all_continuous_matches_whole ($str, $re) {
    my @res;
    my $pos = pos($str) // 0;    # is it correct that undef pos means 0 ?
    while ($str =~ m{\G($re)}gc) {
        $pos = pos($str);
        push @res, $1;
    }
    wantarray ? (\@res, $pos) : \@res
}

# ^ XX ach  pos 0  auto since  str is COPIED MAN  KRST

sub fullmatching ($fn) {
    sub ($str, $re) {
        my ($results, $restpos) = $fn->($str, $re);
        my $rem = substr($str, $restpos);
        $rem =~ /^\s*\z/ or die "non-matching remainder: " . show($rem);
        $results
    }
}

# main> all_matches1 "foo barO", qr/(o)/i
# $VAR1 = [
#           'o',
#           'o',
#           'O'
#         ];
# main> all_matches_whole "foo barO", qr/o/i
# $VAR1 = [
#           'o',
#           'o',
#           'O'
#         ];
# main> all_continuous_matches_whole "oOo barO", qr/o/i
# $VAR1 = [
#           'o',
#           'O',
#           'o'
#         ];
# $VAR2 = 3;
# main> all_continuous_matches_whole "BoOo barO", qr/o/i
# $VAR1 = [];
# $VAR2 = 0;

use Getopt::Long;
our ($debug, $opt_repl);
GetOptions("debug" => \$debug, "repl" => \$opt_repl, "help" => sub {usage})
    or exit 1;

my $in = do { local $/; <> };
$in .= "\n" unless $in =~ /\n\z/;

package PFLANZE::Test {
    use FP::Struct ["input", "results"];

    sub string ($self) {
        my $results = $self->results;
        if ($results->length > 1) {
            my $input = $self->input;
            my $inp2  = $input =~ /;/ ? "do { $input }" : $input;
            "TEST { [ $inp2 ] } [ " . $results->strings_join(", ") . " ];\n"
        } else {
            "TEST { " . $self->input . " } " . $results->first . ";\n"
        }
    }
    _END_
}
PFLANZE::Test::constructors->import;

my $Namespace  = qr/[a-zA-Z_]\w*(?:::[a-zA-Z_]\w*)*/s;
my $Prompt     = qr/${Namespace}>/s;
my $Result     = qr/\n\$VAR\d+ = (.*?); */s;
my $Invocation = qr/${Prompt}\s*(.*?)($Result(?:$Result)*)\n/s;

sub matches($in) {
    my $a = fullmatching(\&all_continuous_matches_whole)->($in, $Invocation);
    $a->map(
        sub ($inv) {
            my ($input, $_results) = $inv =~ $Invocation or die "bug";
            my $results
                = fullmatching(\&all_continuous_matches1)->($_results, $Result);

            # use FP::Repl;repl;
            Test($input, $results)
        }
    )
}

TEST {
    my $in = q&main> all_matches1 "foo barO", qr/(o)/i
$VAR1 = [
          'o',
          'o',
          'O'
        ];
main> all_matches_whole "foo barO", qr/o/i
$VAR1 = [
          'o',
          'o',
          'O'
        ];
main> all_continuous_matches_whole "oOo barO", qr/o/i
$VAR1 = [
          'o',
          'O',
          'o'
        ];
$VAR2 = 3;
main> all_continuous_matches_whole "BoOo barO", qr/o/i
$VAR1 = [];
$VAR2 = 0;
    &;
    matches($in)->map(the_method "string")->join("")
}
q&TEST { all_matches1 "foo barO", qr/(o)/i } [
          'o',
          'o',
          'O'
        ];
TEST { all_matches_whole "foo barO", qr/o/i } [
          'o',
          'o',
          'O'
        ];
TEST { [ all_continuous_matches_whole "oOo barO", qr/o/i ] } [ [
          'o',
          'O',
          'o'
        ], 3 ];
TEST { [ all_continuous_matches_whole "BoOo barO", qr/o/i ] } [ [], 0 ];
&;

if ($opt_repl) {
    require FP::Repl;
    FP::Repl::repl();
} else {
    my $strs = matches($in)->map(the_method "string");
    $strs = $strs->intersperse("----") if $debug;
    $strs->for_each(\&xprint);
}

#use Chj::ruse;
#use Chj::Backtrace;

