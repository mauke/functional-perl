#!/usr/bin/env perl

use strict;
use warnings FATAL => 'uninitialized';
use utf8;

use Cwd 'abs_path';

my ($mydir, $myname);

BEGIN {
    my $location = (-l $0) ? abs_path($0) : $0;
    $location =~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname) = ($1, $2);
}

use lib "$mydir/../lib";

use Chj::xtmpfile;
use Chj::xopen 'xopen_read';

(my $email = 'ch%christianjaeger,ch') =~ tr/%,/@./;

sub usage {
    print STDERR map {"$_\n"} @_ if @_;
    print "$myname --op opname file(s)

  (Christian Jaeger <$email>)
";
    exit(@_ ? 1 : 0);
}

use Getopt::Long;
my $verbose = 0;
my @opt_op;

#our $opt_dry;
GetOptions(
    "verbose" => \$verbose,
    "help"    => sub {usage},
    "op=s"    => sub {
        my (undef, $val) = @_;
        push @opt_op, $val;
    },

    #"dry-run"=> \$opt_dry,
) or exit 1;

@opt_op or usage "no op given, use the --op option";

my %ops = (

    # [ needs_whole_file, proc ]
    opspaces => [
        0,
        sub {
            if (/http|href/) {
                $_
            } else {
                s{ ([^/>=~<!|+*-]) (=|=>|==|=~|/=|//=|>=|<=|<<|>>|!=|\|\||\|\|=|\+=|-=|\*=) ([^/>=~<!|]) }{
            my ($a,$b,$c)=($1,$2,$3);
            my $all = "$a$b$c";
            my $pre= substr($_, 0, pos($_)+1);
            my $is_perl = 0;
            if ($b eq "=>") {
                $is_perl = 1
            } elsif (not substr($pre, length($pre)-1, 1)=~ /\w/) {
                $is_perl = 1
            } elsif (my ($sigil) = $pre =~ /([^\w])[A-Za-z_]\w*\s*$/) {
                $is_perl= $sigil =~ /[\$*&@%]/
            }
            #use FP::Repl;repl;
            if ($is_perl) {
                ($a eq " " ? $a : "$a ").$b.($c eq " " ? $c : " $c")
            } else {
                $all
            }
        }sgex and s/[ \t]*$//;
                $_
            }
        }
    ],

    functionparameters2signatures => [
        1,
        sub {
            s{
         \b(method|fun)(\s+\w+)
         (?:
             (\s*\(\s*)
             ([^()]*?)
             (\s*\))
         )?
         (\s*\{)
    }{
         my ($which,$name,$a,$b,$c,$end)=($1,$2,$3,$4,$5,$6);
         "sub$name"
           . ($which eq "method" ? 
              (defined($b) ? $a.(length($b) ? q{$self, }.$b : q{$self}).$c
               : q{($self)})
              : "$a$b$c")
           . $end
    }sgex;
            $_
        }
    ],
);

my @op = map { $ops{$_} // die "unknown op '$_'" } @opt_op;

my %needs_whole_file = map { $_->[0] ? (1 => undef) : (0 => undef) } @op;

(keys %needs_whole_file) == 1
    or die
    "can't satisfy ops of different needs_whole_file requirement at the same time";

my ($needs_whole_file) = keys %needs_whole_file;

for my $file (@ARGV) {
    my $f     = xopen_read $file;
    my @lines = do {
        local $/ = $needs_whole_file ? undef : $/;
        $f->xreadline;
    };
    $f->xclose;

    my $t = xtmpfile $file;
    $t->xprint(
        map {
            for my $op (@op) {
                my (undef, $proc) = @$op;
                $_ = &$proc($_);
            }
            $_
        } @lines
    );
    $t->xclose;
    $t->xputback;
}

